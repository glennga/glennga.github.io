---
layout: essay
type: essay
title: I Git By With A Little Help From My Friends
date: 2017-12-15
labels:
  - Version Control
  - Git
---
<img class="ui image" src="http://smutch.github.io/VersionControlTutorial/_images/vc-xkcd.jpg">

I am in love with Git. I'll admit, I had a tough time understanding it and the logic behind why we should do it- but it's been a lifesaver so many times. Configuration management is a very real problem, and Git is now a necessity for every project I start or work on. Collaboration has never been this easy before!

## What the Heck is Git?
Is this some misspelling of the word 'Got'? 'Gat'? 'Goat'? Well, *Git* is a type of version control system.

To understand Git, let's first talk about what *version control* is. Let's start off with some code! A basic Hello World in Python, saved as `hw.py`. You add some jazz to it by adding some `*`s and `~`s, who doesn't love a bunch of those.
```
print("***~~~ Hello *** World ~~~***")
```

Everything looks great, we compile and everything runs. Uh-oh, your client now wants your code to print "Hello Earth"! Let's make some changes, and save this again to our file `hw.py`.
```
print("Hello Earth")
```

Argh! Your client doesn't like this look. They want it the old way. But wait, what was the old way? You wrote that code a month ago, you don't remember what you typed. Was it one `*` or three? Maybe they sent an email? You check for hours and... nothing. You regretfully tell your client this is not possible. 

Version control allows us to put these problems behind us. You can keep different versions of the same file and you don't have to disappoint your client with the news! Think of version control as a fancy time machine, where you can create alternate timelines and jump between them as you please. 

But wait- there's more! Now you and your friends can jump between these alternate realities, and you can track who made what changes to each timeline. You can merge timelines together, jump back in time, leave little notes for your friends with every change you make, and even create more versions of your set of alternate timelines! 
```
Timeline: The Cool One
Editor: Glenn Galvizo

Changes:
.
.
- speedOfLight = 299792458
+ speedofLight = 300000000
.
.

Message: Changed the speed of light to a nice round number. 
```

## How Do I Use This New Power? 
Git. There are other version control systems (SVN, Subversion), but I am sure that this is the most widely used. Below is a simple workflow for using Git (courtesy of codingbone.files.wordpress.com).

<img class="ui image" src="https://cdn-images-1.medium.com/max/2000/1*S1fNUzJCu7ftH5F-Gk6YOw.png">

To start, most users sign up with some Git repository hosting service. GitHub is the most popular right now. You want to start a project with version control, so you create a repository on GitHub. This is a *remote repository*. You can edit your files on this remote repository using the GitHub website, but this is less than ideal. What you want is a *local repository*, which is stored on your computer. You can get here by using `git clone` with your repo on GitHub.
```
git clone some-remote-repo ~/my-local-repo
```

We now have a remote repository and a local repository. Think of these as two different versions of your *set of timelines*. You may thinking, "Well if this a set of timelines, what is the actual timeline? This is confusing!". With great power comes great understanding, and misusing version control can be just as bad not having version control at all. Just take a deep breath, and let's move forward. `:-)`

The actual timelines here are known as *branches*. Your default branch is known as the *master branch*. You can (and should) make more branches for different project milestones. You create branches with the command:

```
git checkout -b milestone-1
```

We can switch back to our master using the same method, without the `-b`.

```
git checkout master
```

The real power is your ability to merge these branches together. I am currently in the master branch, and I want to merge the milestone-1 branch to master.

```
git merge milestone-1
```

And just like that, you've created alternate timelines and merged them together. 

Each *branch* is where you edit and create your local repo to your heart's content. When you want to make a checkpoint, you `git add` to add files to save. Here, I am adding new files `look-ma-no-hands*` and editing the file `handlebars.cpp`. We use `git add` for both editing and adding.

```
git add look-ma-no-hands.cpp
git add look-ma-no-hands.h
git add handlebars.cpp
```

 All of changes are now in this staging area, nothing is saved yet. To actually create a checkpoint and move these files out of staging, you `git commit` with a descriptive message of what distinguishes the past checkpoint from this one.

```
git commit -m "Mother can now see me without hands."
```

Scared you'll lose your changes if your computer dies? Simply `git push` your changes to the remote repository. Now you have your code in two separate places! What if you only want mother to see one hand? What about our initial problem of your client wanting an old version of the code to work? Easy peezy, just `git log` to see the *commit* you want `git checkout` the version of the repo we want (or just a select few files with `git reset`) and version you need. 

```
git log --oneline
80012de Father can now see me without hands.
b4118f2 Mother can now see me without hands.
812fb7f Added handlebars.
```

Alrighy, so we want to go back to the commit `b4118f2`. We can create a new branch holding our master branch at the time of this commit. 

```
git checkout -b mother-hands-old b4118f2
```

We can then modify the files we want here...

```
mv look-ma-no-hands.h look-ma-one-hand.h
mv look-ma-no-hands.cpp look-ma-one-hand.cpp
-- do changes here --
```

And then just merge this branch back to our master!

```
git add look-ma-one-hand.*
git commit -m "Mother can now see me with one hand."
git checkout master
git merge master 
```

You still have the file `handlebars.cpp` and all of your changes, you didn't touch the Father commit here, and you didn't have to dig through a bunch of emails. 

The last thing we need to do is *push* our changes to our remote branch:

```
git push
```

If you are working on a team project, then you can pull your changes from the remote repository using:

```
git pull
```

And that's a simple Git workflow in a nutshell! 

## Another Ineffective Version Control Story

Back in high school, I used to develop routines for robots to follow without any sort of effective version control. It was **awful**. As I approached my senior year, I had six years of code for different robots and different versions of the same robot. "Did I write that subroutine for this robot?", "Are the distances and times up-to-date for this routine?", "How did I do this last year?" These were questions that I asked weekly. 

I remember this particularly infuriating afternoon, I had just finished fine tuning a bunch of parameters. This took me about a week to get everything right. I had this in a single header file:

```
ARM_DOWN = 90;
ARM_HIGH = 1001;
.
.
.
DRIVE_LEFT_CORRECTION = 10;
.
.
.
```

I was working off a flash drive at the time and accidently deleted this header file. I check the recycle bin and... nothing. I check the folder again and... nothing. I check the flash drive trash and... nothing. The file was gone! But wait, I had some backups at the time. Which parameters did I change from this backup? Was it `ARM_HIGH`? `ARM_MID`? I had lost a week's worth of code just like that.

And collaboration? Just as frustrating. I would have to keep emailing with the other programmer, and had to make sure we always had the same changes. I genuinely had no idea how more than several people worked on a codebase, and just assumed it was some magic or dumb luck. Turns out, they were just on version control!

## Github and Git

<img class="ui image" src="https://spin.atomicobject.com/wp-content/uploads/20171003153036/github-logo.png">

I started using Bitbucket as my Git host, moved to GitLab, and then ended up on GitHub. I believe GitHub is the best host by a large margin, and that it indeed made Git popular. 

1. You can search for public repositories easily, and this makes contributing to open source code a breeze. This created a strong community around GitHub.
2. An easy-to-use interface online interface which lowers the barrier to move/start a Git project.
3. A user can create Kanban boards and issue tracking using GitHub itself.
4. That tiled contribution visualization on profiles makes users want to fill it with green (maybe, probably not).
5. Their little Octocat mascot.

I'll touch on that first point a little more: **communities drive technologies**. I'm sure there are equally as good version control systems out there, but GitHub gave us an easy way to integrate code sharing with Git. I can give employers my GitHub account and they can see all my projects at a quick glance. I can even make Kanban boards and track issues on GitHub itself! Hell, this portfolio is hosted on GitHub! 

## Final Thoughts

Version control is tough problem to tackle, but Git is a wonderful solution. Someone once described software development as an actual video game, and pushing changes to a Git repo as creating a checkpoint. You can always go back to this checkpoint if you *die* (mess up some code badly), and other people can start from your checkpoint to help you beat the level. It's not the best analogy, but it got the basic point across to me at the time.

TLDR: Version control is good.

